<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>GPT-5-nano Test</title>
<style>
#out {
  white-space: pre-wrap;
  padding: 10px;
  border: 1px solid #ccc;
  margin-top: 10px;
}
</style>
</head>
<body>

<h3>GPT-5-nano 動作テスト</h3>

API Key:
<input id="apiKey" type="password" size="60" placeholder="sk-..." />
<label style="margin-left:8px;">
  <input id="noSaveApiKey" type="checkbox">
  API Key を保存しない
</label>
<button id="clearApiKey" type="button" style="margin-left:8px;">保存されたAPI Keyを削除</button>
<br><br>

モデル名: <input id="model" value="gpt-5-nano">
<button id="toggleModel" type="button">切替</button><br><br>

reasoning_effort:
<label><input type="radio" name="reasoning" value="none"> none</label>
<label><input type="radio" name="reasoning" value="minimal" checked> minimal</label>
<label><input type="radio" name="reasoning" value="low"> low</label>
<label><input type="radio" name="reasoning" value="medium"> medium</label>
<label><input type="radio" name="reasoning" value="high"> high</label>
<br><br>

verbosity:
<label><input type="radio" name="verbosity" value="low"> low</label>
<label><input type="radio" name="verbosity" value="medium" checked> medium</label>
<label><input type="radio" name="verbosity" value="high"> high</label>
<br><br>

ルール: <br>
<textarea id="msg_rule" rows="4" cols="50"></textarea><br><br>

メッセージ: <br>
<textarea id="msg" rows="4" cols="50"></textarea><br><br>

<button id="run">送信</button>

<div id="out"></div>

<script>

// ===== IndexedDB(kv) 永続化：ルール/メッセージ/API Key を保存・復元 =====
const DB_NAME = "gpt_test_db";
const DB_VER = 1;
const STORE = "kv";

const KEY_RULE = "tmp_msg_rule";
const KEY_MSG  = "tmp_msg";
const KEY_API  = "tmp_api_key";
const KEY_NO_SAVE_API = "no_save_api_key";

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VER);
    req.onupgradeneeded = () => {
      const db = req.result;
     if (!db.objectStoreNames.contains(STORE)) {
        db.createObjectStore(STORE);
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function idbGet(key) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, "readonly");
    const st = tx.objectStore(STORE);
    const req = st.get(key);
    req.onsuccess = () => resolve(req.result ?? null);
    req.onerror = () => reject(req.error);
    tx.oncomplete = () => db.close();
  });
}

async function idbSet(key, val) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, "readwrite");
    const st = tx.objectStore(STORE);
    const req = st.put(val, key);
    req.onsuccess = () => resolve(true);
    req.onerror = () => reject(req.error);
    tx.oncomplete = () => db.close();
  });
}

async function idbDel(key) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, "readwrite");
    const st = tx.objectStore(STORE);
    const req = st.delete(key);
    req.onsuccess = () => resolve(true);
    req.onerror = () => reject(req.error);
    tx.oncomplete = () => db.close();
  });
}

// 旧 localStorage から IndexedDB へ初回移行（あれば）
async function migrateFromLocalStorageOnce() {
  const legacy = [
    [KEY_RULE, localStorage.getItem(KEY_RULE)],
    [KEY_MSG,  localStorage.getItem(KEY_MSG)],
    [KEY_API,  localStorage.getItem(KEY_API)],
  ];
  let migrated = false;
  for (const [k, v] of legacy) {
    if (v !== null && v !== undefined) {
      // IndexedDB 側が空なら入れる（上書きしない）
      const cur = await idbGet(k);
      if (cur === null) {
        await idbSet(k, v);
        migrated = true;
      }
    }
  }
  if (migrated) {
    localStorage.removeItem(KEY_RULE);
    localStorage.removeItem(KEY_MSG);
    localStorage.removeItem(KEY_API);
  }
}

const ruleEl  = document.getElementById("msg_rule");
const msgEl   = document.getElementById("msg");
const apiKeyEl = document.getElementById("apiKey");
const noSaveApiKeyEl = document.getElementById("noSaveApiKey");
const clearApiKeyBtn = document.getElementById("clearApiKey");

// 起動時に復元
(async () => {
  try {
    await migrateFromLocalStorageOnce();
    const savedRule = await idbGet(KEY_RULE);
    if (savedRule !== null) ruleEl.value = savedRule;
    const savedMsg = await idbGet(KEY_MSG);
    if (savedMsg !== null) msgEl.value = savedMsg;

    // 「API Key を保存しない」設定を復元
    const noSave = await idbGet(KEY_NO_SAVE_API);
    noSaveApiKeyEl.checked = (noSave === "1");

    // 保存しない設定がOFFのときだけ API Key を復元
    if (!noSaveApiKeyEl.checked) {
      const savedApi = await idbGet(KEY_API);
      if (savedApi !== null) apiKeyEl.value = savedApi;
    }
  } catch (e) {
   console.warn("IndexedDB restore failed:", e);
  }
})();

// 入力のたびに保存（軽くデバウンス）
function debounce(fn, ms) {
  let t;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...args), ms);
  };
}

const saveRule = debounce(() => idbSet(KEY_RULE, ruleEl.value), 150);
const saveMsg  = debounce(() => idbSet(KEY_MSG, msgEl.value), 150);
const saveApi  = debounce(async () => {
  if (noSaveApiKeyEl.checked) return; // 保存しない
  await idbSet(KEY_API, apiKeyEl.value.trim());
}, 150);

ruleEl.addEventListener("input", saveRule);
msgEl.addEventListener("input", saveMsg);
apiKeyEl.addEventListener("input", saveApi);


// 保存しないチェック：設定を保存し、ONならAPI Keyも消す（入力欄も空に）
noSaveApiKeyEl.addEventListener("change", async () => {
  try {
    await idbSet(KEY_NO_SAVE_API, noSaveApiKeyEl.checked ? "1" : "0");
    if (noSaveApiKeyEl.checked) {
      await idbDel(KEY_API);
      apiKeyEl.value = "";
    } else {
      // OFFに戻した直後は、入力を待つ（ここで復元はしない方が分かりやすい）
    }
  } catch (e) {
    console.warn("toggle noSaveApiKey failed:", e);
  }
});

// 保存されたAPI Keyを削除ボタン：IndexedDBから消して入力欄も空に
clearApiKeyBtn.addEventListener("click", async () => {
  try {
    await idbDel(KEY_API);
    apiKeyEl.value = "";
    alert("保存された API Key を削除しました。");
  } catch (e) {
    console.warn("clear api key failed:", e);
    alert("削除に失敗しました。");
  }
});


// モデル切替（gpt-5-nano ⇄ gpt-5-mini）
document.getElementById("toggleModel").onclick = () => {
  const el = document.getElementById("model");
  const cur = el.value.trim();
  // 押すと「gpt-5-nano 以外なら gpt-5-nano、gpt-5-nano なら gpt-5-mini」
  el.value = (cur === "gpt-5-nano") ? "gpt-5-mini" : "gpt-5-nano";
};



document.getElementById("run").onclick = async () => {

  const apiKey = apiKeyEl.value.trim();
  const model  = document.getElementById("model").value.trim();
  const content = document.getElementById("msg").value;
  const content2 = document.getElementById("msg_rule").value;

  const reasoning_effort =
    document.querySelector('input[name="reasoning"]:checked')?.value;
  const verbosity =
    document.querySelector('input[name="verbosity"]:checked')?.value;

  if (!apiKey) {
    alert("API Key を入力してください");
    return;
  }

  document.getElementById("out").textContent = "実行中...\n";

  try {
let res;
if(model.includes("gpt-5") || model.includes("gpt-6") || model.includes("gpt-7") || model.includes("gpt-8") || model.includes("gpt-9")) {
    res = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": "Bearer " + apiKey,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model,
        messages: [
          {
      "role": "system",
      "content": content2
    },
          {
      "role": "user",
      "content": content
    }
        ],
        // ★ gpt-5-nano は temperature をサポートしない
        // temperature: 1 ← これすら書かない方が安全
        //max_tokens: 2000,
        stream: false,
        reasoning_effort,
        verbosity,
service_tier: "flex", // ←追加
      })
    });
}
else
{
    res = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": "Bearer " + apiKey,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model,
        messages: [
          { role: "user", content }
        ],
        // ★ gpt-5-nano は temperature をサポートしない
         temperature: 1,
        max_tokens: 2000,
        stream: false
      })
    });
}

    const data = await res.json();

    // 返信内容
    const text = data?.choices?.[0]?.message?.content ?? "(content なし)";

    document.getElementById("out").textContent =
      "【返信】\n" + text + "\n\n【JSON】\n" +
      JSON.stringify(data, null, 2);

  } catch (e) {
    document.getElementById("out").textContent = "Error:\n" + e;
  }
};
</script>

</body>
</html>

